{"version":3,"file":"resilience-BMymzc7Q.js","sources":["../../src/sketches/resilience.ts"],"sourcesContent":["import p5 from 'p5';\n\ninterface Particle {\n  position: p5.Vector;\n  velocity: p5.Vector;\n  acceleration: p5.Vector;\n  color: number[];\n  size: number;\n  maxSpeed: number;\n  innerStrength: number;  // How strongly it resists external forces\n  originalPosition: p5.Vector;\n  connectionRadius: number;\n  type: 'core' | 'shield' | 'flow' | 'wisdom' | 'balance';\n  phase: number;         // For oscillating behavior\n  life: number;          // For particle lifecycle\n  maxLife: number;       // Maximum lifetime\n  targetOpacity: number; // For fade effects\n  currentOpacity: number;\n  // Add spatial hash grid index\n  gridX: number;\n  gridY: number;\n}\n\nconst sketch = (p: p5) => {\n  let particles: Particle[] = [];\n  let time = 0;\n  let globalPhase = 0;\n  \n  // Add click interaction variables\n  let isClicking = false;\n  let clickTime = 0;\n  let clickPattern = 0;\n  const CLICK_PATTERNS = 5; // Number of different click patterns\n  \n  // Constants for optimization\n  const GRID_SIZE = 100; // Size of spatial hash grid cells\n  const PARTICLE_COUNTS = {\n    core: 10,    // Reduced from 20\n    shield: 20,  // Reduced from 40\n    flow: 15,    // Reduced from 30\n    wisdom: 15,  // Reduced from 25\n    balance: 20  // Reduced from 35\n  };\n  \n  // Theme colors representing different aspects of resilience\n  const themeColors = {\n    core: [255, 255, 255, 200],     // White - inner strength and purity\n    shield: [0, 150, 255, 180],     // Blue - protection and stability\n    flow: [255, 100, 0, 180],       // Orange - adaptability and energy\n    wisdom: [150, 0, 255, 180],     // Purple - knowledge and understanding\n    balance: [0, 255, 150, 180]     // Green - harmony and growth\n  };\n\n  // Spatial hash grid for faster neighbor lookup\n  const grid: Map<string, Particle[]> = new Map();\n  \n  const getGridKey = (x: number, y: number): string => {\n    const gridX = Math.floor(x / GRID_SIZE);\n    const gridY = Math.floor(y / GRID_SIZE);\n    return `${gridX},${gridY}`;\n  };\n\n  const updateGrid = () => {\n    grid.clear();\n    particles.forEach(particle => {\n      const key = getGridKey(particle.position.x, particle.position.y);\n      if (!grid.has(key)) {\n        grid.set(key, []);\n      }\n      grid.get(key)!.push(particle);\n    });\n  };\n\n  const getNeighbors = (particle: Particle): Particle[] => {\n    const neighbors: Particle[] = [];\n    const gridX = Math.floor(particle.position.x / GRID_SIZE);\n    const gridY = Math.floor(particle.position.y / GRID_SIZE);\n    \n    // Check neighboring cells\n    for (let x = -1; x <= 1; x++) {\n      for (let y = -1; y <= 1; y++) {\n        const key = `${gridX + x},${gridY + y}`;\n        const cell = grid.get(key);\n        if (cell) {\n          neighbors.push(...cell);\n        }\n      }\n    }\n    return neighbors;\n  };\n\n  const createParticle = (x: number, y: number, type: Particle['type']): Particle => ({\n    position: p.createVector(x, y),\n    velocity: p.createVector(0, 0),\n    acceleration: p.createVector(0, 0),\n    color: themeColors[type],\n    size: type === 'core' ? 4 : \n          type === 'shield' ? 3 :\n          2,\n    maxSpeed: type === 'flow' ? 4 :\n              type === 'core' ? 1.5 :\n              2.5,\n    innerStrength: type === 'core' ? 0.95 :\n                   type === 'shield' ? 0.9 :\n                   0.8,\n    originalPosition: p.createVector(x, y),\n    connectionRadius: type === 'core' ? 80 :\n                     type === 'shield' ? 60 :\n                     40,\n    type,\n    phase: p.random(p.TWO_PI),\n    life: 0,\n    maxLife: type === 'flow' ? 200 : Infinity,\n    targetOpacity: type === 'core' ? 1 :\n                   type === 'shield' ? 0.9 :\n                   0.8,\n    currentOpacity: 0,\n    gridX: 0,\n    gridY: 0\n  });\n\n  const createParticleSystem = () => {\n    particles = [];\n    const centerX = p.width / 2;\n    const centerY = p.height / 2;\n    const radius = Math.min(p.width, p.height) * 0.3;\n\n    // Create particles with reduced counts\n    Object.entries(PARTICLE_COUNTS).forEach(([type, count]) => {\n      for (let i = 0; i < count; i++) {\n        const angle = (i / count) * p.TWO_PI;\n        const distance = type === 'core' ? radius * 0.3 :\n                        type === 'shield' ? radius * 0.6 :\n                        type === 'flow' ? p.random(radius * 0.4, radius * 0.8) :\n                        type === 'wisdom' ? p.random(radius * 0.5, radius * 0.9) :\n                        p.random(radius * 0.7, radius);\n        const x = centerX + p.cos(angle) * distance;\n        const y = centerY + p.sin(angle) * distance;\n        particles.push(createParticle(x, y, type as Particle['type']));\n      }\n    });\n  };\n\n \n // Modify constants for continuous cycling\n  const PHASE_SPEED = 0.001; // Speed of the global phase\n  const TRANSITION_SPEED = 0.02; // Speed of transitions between states\n  \n  // Add cycle state tracking\n  let cyclePhase = 0;\n  let targetPositions: Map<Particle, p5.Vector> = new Map();\n  let currentState = 0;\n  const NUM_STATES = 4; // Number of different system states\n\n  const calculateTargetPositions = (state: number) => {\n    const centerX = p.width / 2;\n    const centerY = p.height / 2;\n    const radius = Math.min(p.width, p.height) * 0.3;\n    \n    particles.forEach(particle => {\n      const baseAngle = (cyclePhase + particle.phase) % p.TWO_PI;\n      let angle = baseAngle;\n      let distance = radius * 0.5; // Default distance\n      \n      switch(state) {\n        case 0: // Concentric circles\n          angle = baseAngle;\n          distance = particle.type === 'core' ? radius * 0.3 :\n                    particle.type === 'shield' ? radius * 0.6 :\n                    particle.type === 'flow' ? radius * 0.8 :\n                    particle.type === 'wisdom' ? radius * 0.9 :\n                    radius;\n          break;\n          \n        case 1: // Spiral formation\n          angle = baseAngle * 2;\n          distance = radius * (0.3 + (baseAngle / p.TWO_PI) * 0.7);\n          break;\n          \n        case 2: // Wave pattern\n          angle = baseAngle;\n          distance = radius * (0.5 + Math.sin(baseAngle * 3) * 0.3);\n          break;\n          \n        case 3: // Dynamic clusters\n          const clusterAngle = Math.floor(baseAngle / (p.TWO_PI / 6)) * (p.TWO_PI / 6);\n          angle = clusterAngle + (baseAngle % (p.TWO_PI / 6)) * 0.5;\n          distance = radius * (0.4 + Math.cos(baseAngle * 4) * 0.3);\n          break;\n      }\n      \n      const x = centerX + Math.cos(angle) * distance;\n      const y = centerY + Math.sin(angle) * distance;\n      targetPositions.set(particle, p.createVector(x, y));\n    });\n  };\n\n  const updateParticlePositions = () => {\n    particles.forEach(particle => {\n      const target = targetPositions.get(particle);\n      if (target) {\n        // Calculate desired velocity towards target\n        const desired = p5.Vector.sub(target, particle.position);\n        const distance = desired.mag();\n        \n        if (distance > 1) {\n          desired.normalize();\n          desired.mult(particle.maxSpeed);\n          \n          // Steer towards target\n          const steer = p5.Vector.sub(desired, particle.velocity);\n          steer.limit(0.1);\n          particle.acceleration.add(steer);\n        }\n      }\n    });\n  };\n\n  // Add click pattern calculation function\n  const calculateClickPattern = (pattern: number, particle: Particle) => {\n    const centerX = p.width / 2;\n    const centerY = p.height / 2;\n    const radius = Math.min(p.width, p.height) * 0.3;\n    const clickX = p.mouseX;\n    const clickY = p.mouseY;\n    const angleToClick = Math.atan2(clickY - centerY, clickX - centerX);\n    const baseAngle = (cyclePhase + particle.phase) % p.TWO_PI;\n    \n    let targetX, targetY;\n    \n    switch(pattern) {\n      case 0: // Concentric rings around click\n        const ringRadius = radius * (0.3 + (particle.type === 'core' ? 0 :\n                                          particle.type === 'shield' ? 0.2 :\n                                          particle.type === 'flow' ? 0.4 :\n                                          particle.type === 'wisdom' ? 0.6 : 0.8));\n        targetX = clickX + Math.cos(baseAngle) * ringRadius;\n        targetY = clickY + Math.sin(baseAngle) * ringRadius;\n        break;\n        \n      case 1: // Spiral from click\n        const spiralRadius = radius * (0.2 + (baseAngle / p.TWO_PI) * 0.8);\n        const spiralAngle = baseAngle * 3 + angleToClick;\n        targetX = clickX + Math.cos(spiralAngle) * spiralRadius;\n        targetY = clickY + Math.sin(spiralAngle) * spiralRadius;\n        break;\n        \n      case 2: // Wave pattern from click\n        const waveRadius = radius * (0.4 + Math.sin(baseAngle * 4) * 0.3);\n        const waveAngle = baseAngle + angleToClick;\n        targetX = clickX + Math.cos(waveAngle) * waveRadius;\n        targetY = clickY + Math.sin(waveAngle) * waveRadius;\n        break;\n        \n      case 3: // Particle type clusters\n        const clusterAngle = (particle.type === 'core' ? 0 :\n                            particle.type === 'shield' ? p.TWO_PI / 5 :\n                            particle.type === 'flow' ? p.TWO_PI * 2 / 5 :\n                            particle.type === 'wisdom' ? p.TWO_PI * 3 / 5 :\n                            p.TWO_PI * 4 / 5) + baseAngle * 0.2;\n        const clusterRadius = radius * 0.6;\n        targetX = clickX + Math.cos(clusterAngle) * clusterRadius;\n        targetY = clickY + Math.sin(clusterAngle) * clusterRadius;\n        break;\n        \n      case 4: // Explosion pattern\n        const explosionRadius = radius * (0.2 + (1 - clickTime / 60) * 0.8);\n        const explosionAngle = baseAngle + angleToClick;\n        targetX = clickX + Math.cos(explosionAngle) * explosionRadius;\n        targetY = clickY + Math.sin(explosionAngle) * explosionRadius;\n        break;\n    }\n    \n    return p.createVector(targetX, targetY);\n  };\n\n  p.setup = () => {\n    const container = document.getElementById('sketch-container');\n    if (!container) {\n      console.error('Sketch container not found');\n      return;\n    }\n\n    const canvas = p.createCanvas(container.clientWidth, container.clientHeight);\n    canvas.parent('sketch-container');\n    p.background(0, 0 , 0 , .2);\n    p.colorMode(p.RGB, 255, 255, 255, 255);\n\n   \n    createParticleSystem();\n  };\n\n  p.draw = () => {\n    time += 0.01;\n    cyclePhase = (cyclePhase + PHASE_SPEED) % p.TWO_PI;\n    globalPhase += 0.005;\n    p.background(0, 0, 0, .2);\n\n    // Update click time\n    if (isClicking) {\n      clickTime++;\n    }\n\n    // Update system state (only when not clicking)\n    if (!isClicking && cyclePhase < 0.1) {\n      currentState = (currentState + 1) % NUM_STATES;\n    }\n\n    // Calculate target positions based on click state\n    if (isClicking) {\n      particles.forEach(particle => {\n        const target = calculateClickPattern(clickPattern, particle);\n        targetPositions.set(particle, target);\n      });\n    } else {\n      calculateTargetPositions(currentState);\n    }\n\n    // Update grid for neighbor lookup\n    updateGrid();\n\n    // Update and draw particles\n    particles.forEach(particle => {\n      // Update particle phase\n      particle.phase = (particle.phase + 0.01) % p.TWO_PI;\n\n      // Update physics with increased speed during click\n      const currentTransitionSpeed = isClicking ? TRANSITION_SPEED * 2 : TRANSITION_SPEED;\n      updateParticlePositions();\n\n      // Apply mouse force with distance-based strength\n      if (p.mouseX > 0 && p.mouseY > 0) {\n        const dx = particle.position.x - p.mouseX;\n        const dy = particle.position.y - p.mouseY;\n        const distanceToMouse = Math.sqrt(dx * dx + dy * dy);\n        if (distanceToMouse < 150) {\n          const mouseStrength = (1 - distanceToMouse / 150) * (1 - particle.innerStrength);\n          particle.acceleration.add(dx * mouseStrength * 0.01, dy * mouseStrength * 0.01);\n        }\n      }\n\n      // Add noise-based movement (reduced during click)\n      const noiseStrength = isClicking ? 0.05 : 0.1;\n      const noise = p.noise(\n        particle.position.x * 0.005,\n        particle.position.y * 0.005,\n        time\n      ) * p.TWO_PI;\n      const noiseForce = p.createVector(\n        p.cos(noise),\n        p.sin(noise)\n      ).mult(noiseStrength * (1 - particle.innerStrength));\n      particle.acceleration.add(noiseForce);\n\n      // Update velocity and position\n      particle.velocity.add(particle.acceleration);\n      particle.velocity.mult(0.98); // Damping\n      particle.velocity.limit(particle.maxSpeed);\n      particle.position.add(particle.velocity);\n      particle.acceleration.mult(0);\n\n      // Update opacity with dynamic transition speed\n      particle.currentOpacity = p.lerp(\n        particle.currentOpacity,\n        particle.targetOpacity,\n        currentTransitionSpeed\n      );\n\n      // Draw particle\n      p.noStroke();\n      const alpha = particle.currentOpacity * 255;\n      p.fill(particle.color[0], particle.color[1], particle.color[2], alpha);\n      \n      // Add glow effect for core and shield particles\n      if (particle.type === 'core' || particle.type === 'shield') {\n        p.drawingContext.shadowBlur = 10;\n        p.drawingContext.shadowColor = p.color(\n          particle.color[0],\n          particle.color[1],\n          particle.color[2],\n          alpha * 0.5\n        );\n      }\n\n      p.ellipse(particle.position.x, particle.position.y, particle.size);\n      p.drawingContext.shadowBlur = 0;\n\n      // Draw connections\n      const neighbors = getNeighbors(particle);\n      neighbors.forEach(other => {\n        if (other !== particle) {\n          const dx = particle.position.x - other.position.x;\n          const dy = particle.position.y - other.position.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          \n          if (distance < particle.connectionRadius) {\n            const connectionStrength = 1 - distance / particle.connectionRadius;\n            const connectionAlpha = connectionStrength * 100 * particle.currentOpacity;\n            \n            // Different connection styles based on particle types\n            if ((particle.type === 'core' && other.type === 'shield') ||\n                (particle.type === 'shield' && other.type === 'core')) {\n              p.stroke(particle.color[0], particle.color[1], particle.color[2], connectionAlpha * 0.8);\n              p.strokeWeight(2);\n            } else if (particle.type === 'flow' || other.type === 'flow') {\n              p.stroke(particle.color[0], particle.color[1], particle.color[2], connectionAlpha * 0.4);\n              p.strokeWeight(1);\n            } else {\n              p.stroke(particle.color[0], particle.color[1], particle.color[2], connectionAlpha * 0.6);\n              p.strokeWeight(1.5);\n            }\n            \n            p.line(\n              particle.position.x,\n              particle.position.y,\n              other.position.x,\n              other.position.y\n            );\n          }\n        }\n      });\n    });\n  };\n\n  p.windowResized = () => {\n    const container = document.getElementById('sketch-container');\n    if (!container) return;\n    p.resizeCanvas(container.clientWidth, container.clientHeight);\n    createParticleSystem();\n  };\n\n  p.mousePressed = () => {\n    isClicking = true;\n    clickTime = 0;\n    clickPattern = (clickPattern + 1) % CLICK_PATTERNS;\n  };\n\n  p.mouseReleased = () => {\n    isClicking = false;\n  };\n};\n\n// Create a new p5 instance with the sketch\nnew p5(sketch); \n"],"names":["sketch","p","particles","time","isClicking","clickTime","clickPattern","CLICK_PATTERNS","GRID_SIZE","PARTICLE_COUNTS","themeColors","grid","getGridKey","x","y","gridX","gridY","updateGrid","particle","key","getNeighbors","neighbors","cell","createParticle","type","createParticleSystem","centerX","centerY","radius","count","i","angle","distance","PHASE_SPEED","TRANSITION_SPEED","cyclePhase","targetPositions","currentState","NUM_STATES","calculateTargetPositions","state","baseAngle","updateParticlePositions","target","desired","p5","steer","calculateClickPattern","pattern","clickX","clickY","angleToClick","targetX","targetY","ringRadius","spiralRadius","spiralAngle","waveRadius","waveAngle","clusterAngle","clusterRadius","explosionRadius","explosionAngle","container","currentTransitionSpeed","dx","dy","distanceToMouse","mouseStrength","noiseStrength","noise","noiseForce","alpha","other","connectionAlpha"],"mappings":"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"}